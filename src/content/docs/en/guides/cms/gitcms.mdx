---
title: GitCMS & Astro
description: Integrate GitCMS into your Astro project for seamless content management
sidebar:
  label: GitCMS
type: cms
service: GitCMS
i18nReady: true
---

[GitCMS](https://gitcms.blog) is a Chrome extension that transforms GitHub into a powerful headless CMS, providing a Notion-like editing experience for managing static sites built with frameworks like Astro, Next.js, Hugo, Jekyll, and more. It allows developers, clients, and content writers to manage content directly within GitHub's interface without additional servers or complex CMS setups.

## Prerequisites
- An existing Astro project with a GitHub repository.
- A Chrome-based browser installed.

## Setting Up GitCMS

1. Install the [GitCMS Chrome Extension](https://gitcms.blog/extension).
2. Navigate to the Github repository containing your Astro project.
3. In the Chrome Extension menu, click on GitCMS to open the extension.
4. Click on **Init**. You will be redirected to an edit page to create a `gitcms.md` file. If the GitCMS configuration UI is not displayed, you may need to navigate between **Edit**/**Preview** modes or reload the page.
5. Click **Try for Free** or enter your license key if you choose to use a paid plan.
6. Configure GitCMS:
  * **Website URL**: Enter your site's URL (e.g., `https://yourblog.com`).
  * **Repository**: Your Github repository. This value is filled automatically and you should not need to change it.
  * **Media Files Folder**: Specify where media files are stored (e.g., `/public`).
7. Use the **Save & Commit** button to save your configuration. You should now have a `gitcms.md` file in the root of your repository.

## Configuring GitCMS

You can update the GitCMS configuration at any time by opening the `gitcms.md` file in Github. The GitCMS UI should be displayed automatically. Then, click on **Try for Free** or enter your license key to access to your configuration. The interface will allow you to update existing configuration or add new collections.

### Adding Collections
Collections group related content, such as blog posts, pages, or team members.

To create a new collection:

1. Click **Add Collection**
2. Define the **Collection Settings**:
   - **Collection Name**: A unique name for your collection (e.g., `posts`, `pages`, `authors`).
   - **Collection Folder**: The path where your collection is stored (e.g., `/src/data/authors`)
   - **Filename Pattern**: Defines a template for the names of files in this collection by reusing fields from frontmatter (optional)
3. Define the **Frontmatter Fields** by associating a name with a type. The available types are:
   - **title**: For entry titles.
   - **singleline**: For short text like descriptions.
   - **multiline**: For longer content.
   - **datetime**: For dates (e.g. publishing date).
   - **multi_select**: For categories and tags.
   - **file**: For media uploads.
   - **boolean**: For toggles like "draft".
   
You can add as many collections as you like. Then, once you're done editing, click **Save & Commit** to update your configuration.

Here is an example configuration that defines a `posts` collection:
   ```yaml
   ---
   media_path: /public
   repo: YourUsername/your-repo
   website_url: https://yourwebsite.com
   
   collections:
     - name: posts
       file_extension: .md
       filename_pattern: title
       git_path: /src/content/posts
       metadata_schema:
         - name: title
           required: true
           type: title
         - name: description
           required: false
           type: multiline
         - name: date
           required: true
           type: datetime
         - name: image
           required: false
           type: file
         - allowed_values:
             - Product Updates
             - Features
             - Comparison
           name: categories
           required: true
           type: multi_select
         - allowed_values:
             - AuthorName
           name: authors
           required: true
           type: multi_select
         - name: draft
           required: false
           type: boolean
   ---
   ```
   GitCMS generates this automatically, so manual editing is unnecessary.

## Using GitCMS
1. **Open the GitCMS Editor**:
   - Navigate to a Markdown file in your repository.
   - Click the GitCMS icon to toggle between GitHub and GitCMS editors.

2. **Editing Features**:
   - Visual Markdown editing.
   - Structured metadata forms.
   - Media uploads with previews.

## Rendering Content in Astro
Use Astro's Content Collections API to display content.

### Displaying a Collection List
```astro
---
import { getCollection } from 'astro:content';
const posts = await getCollection('posts');
---
<ul>
  {posts.map(post => (
    <li>
      <a href={`/posts/{post.id}`}>{post.data.title}</a>
    </li>
  ))}
</ul>
```

### Displaying a Single Entry
```astro
---
import { getEntry, render } from 'astro:content';

const post = await getEntry('posts', 'my-first-post');
const { Content } = await render(post);
---
<main>
  <h1>{post.data.title}</h1>
  <Content />
</main>
```
For more on querying content, see Astro's [Content Collections documentation](/en/guides/content-collections/).

## Deploying with Astro
Refer to Astro's [deployment guides](/en/guides/deploy/) for hosting options. Since GitCMS stores content in GitHub, deployment remains simple.

## Resources
- [Introducing GitCMS](https://gitcms.blog/posts/introducing-gitcms/)
- [How to Configure GitCMS](https://gitcms.blog/posts/how-to-configure-gitcms/)
- [Frontmatter Fields in GitCMS](https://gitcms.blog/posts/frontmatter-editor/)
- [GitCMS Chrome Extension](https://gitcms.blog)

By integrating GitCMS with Astro, developers and content creators gain a seamless, efficient, and user-friendly content management experience.

